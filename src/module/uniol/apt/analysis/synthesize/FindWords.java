/*-
 * APT - Analysis of Petri Nets and labeled Transition systems
 * Copyright (C) 2014-2016  Uli Schlachter
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

package uniol.apt.analysis.synthesize;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.SortedSet;

import uniol.apt.adt.ts.TransitionSystem;
import uniol.apt.analysis.exception.NonDeterministicException;
import uniol.apt.analysis.synthesize.SynthesizeUtils;

/**
 * Find all words that can be generated by a Petri net from a given class.
 * @author Uli Schlachter
 */
public class FindWords {
	static public interface WordCallback {
		public void call(List<String> wordAsList, String wordAsString, SynthesizePN synthesize);
	}

	static public interface LengthDoneCallback {
		public void call(int length);
	}

	static public void generateList(PNProperties properties, SortedSet<String> alphabet, boolean quickFail, WordCallback wordCallback, LengthDoneCallback lengthDoneCallback) {
		for (String symbol : alphabet)
			if (symbol.length() != 1)
				throw new UnsupportedOperationException(String.format("All symbols in the alphabet"
							+ " must have length 1, but '%s' does not", symbol));

		List<String> currentLevel = Collections.singletonList("");
		List<String> nextLevel = new ArrayList<>();
		while (!currentLevel.isEmpty()) {
			for (String currentWord : currentLevel) {
				for (String c : alphabet) {
					boolean newLetter = !currentWord.contains(c);

					// If "currentWord" is unsolvable, then "word" must also be unsolvable.
					// Otherwise we get a contradiction: The net solving "word" will solve
					// "currentWord" after firing "c" once.
					// Put differently: By prepending letters to solvable words, we are sure to
					// generate all solvable words.
					String word = c + currentWord;
					word = normalizeWord(toList(word), alphabet);
					List<String> wordList = toList(word);

					if (!properties.isKBounded()) {
						// If we have unbounded places, then every prefix of a solvable word is
						// also solvable: Just add a place from which every transition consumes
						// one token. This place's initial marking limits the length of the
						// word.
						// For our purpose this means: If the prefix isn't solvable, then we
						// already know that the word itself isn't solvable either.
						// This is also important for the definition of "minimally unsolvable"
						// (= unsolvable + all proper subwords are solvable).
						if (Collections.binarySearch(currentLevel, normalizeWord(
								wordList.subList(0, wordList.size() - 1), alphabet)) < 0)
							continue;
					} else {
						// In a k-bounded Petri net, every suffix of a solvable word is also
						// solvable. However, a prefix might still be unsolvable. Thus, we use a
						// different definition of "minimally unsolvable" here (= unsolvable +
						// all proper suffixes are solvable).
					}

					// Is "word" PN-solvable with the given properties?
					TransitionSystem ts = SynthesizeUtils.makeTS(wordList);
					SynthesizePN synthesize;
					try {
						synthesize = new SynthesizePN.Builder(ts)
							.setProperties(properties)
							// we don't need failed separation points, if we don't show them
							.setQuickFail(quickFail)
							.buildForLanguageEquivalence();
					} catch (MissingLocationException e) {
						throw new RuntimeException("Not generating locations and "
								+ " yet they were generated wrongly?!", e);
					} catch (NonDeterministicException e) {
						throw new RuntimeException("Generated a deterministic TS and "
								+ " yet it is non-deterministic?!", e);
					}
					wordCallback.call(wordList, word, synthesize);
					if (synthesize.wasSuccessfullySeparated()) {
						nextLevel.add(word);
					}

					if (newLetter)
						// The alphabet is a sorted set. We only extend words in the order that
						// they appear in the alphabet. So if the current letter was new, then
						// all the following ones will be new, too.
						// When extending "ba", "cab" is solvable if and only if "dab" is
						// solvable. So trying other new letters won't produce really "new"
						// words, but only words that are symmetric in the sense that they can
						// be transformed into each other by replacing one letter with another.
						// Avoiding these symmetries in the words we generate helps speeding up
						// this algorithm.
						break;
				}
			}

			int currentLength = currentLevel.iterator().next().length() + 1;
			lengthDoneCallback.call(currentLength);
			currentLevel = nextLevel;
			nextLevel = new ArrayList<>();
			Collections.sort(currentLevel);
		}
	}

	// Transform a String into the list of its characters
	static private List<String> toList(String word) {
		List<String> result = new ArrayList<>(Arrays.asList(word.split("")));
		// some Java versions include "" as first part of the splitted string => try to remove it
		result.remove("");
		return result;
	}

	// Normalize a word into the form that the above loop would generate it in. This means e.g. that the word ends
	// with the first letter of the alphabet.
	static private String normalizeWord(List<String> word, SortedSet<String> alphabet)
	{
		StringBuilder result = new StringBuilder();
		Map<String, String> morphism = new HashMap<>();
		Iterator<String> alphabetIter = alphabet.iterator();

		for (String letter : word) {
			String replacement = morphism.get(letter);
			if (replacement == null) {
				assert alphabetIter.hasNext();
				replacement = alphabetIter.next();
				morphism.put(letter, replacement);
			}
			result.append(replacement);
		}
		return result.toString();
	}
}

// vim: ft=java:noet:sw=8:sts=8:ts=8:tw=120
