/*-
 * APT - Analysis of Petri Nets and labeled Transition systems
 * Copyright (C) 2014-2015  Uli Schlachter
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

package uniol.apt.analysis.synthesize;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.SortedSet;
import java.util.TreeSet;

import uniol.apt.adt.ts.TransitionSystem;
import uniol.apt.analysis.exception.NonDeterministicException;
import uniol.apt.module.AbstractModule;
import uniol.apt.module.AptModule;
import uniol.apt.module.Category;
import uniol.apt.module.Module;
import uniol.apt.module.ModuleInput;
import uniol.apt.module.ModuleInputSpec;
import uniol.apt.module.ModuleOutput;
import uniol.apt.module.ModuleOutputSpec;
import uniol.apt.module.exception.ModuleException;
import static uniol.apt.analysis.synthesize.SynthesizeUtils.*;

/**
 * Find all words that can be generated by a Petri net from a given class.
 * @author Uli Schlachter
 */
@AptModule
public class FindWordsModule extends AbstractModule implements Module {
	public interface WordCallback {
		public void call(List<String> wordAsList, String wordAsString, SynthesizePN synthesize);
	}

	public interface LengthDoneCallback {
		public void call(int length);
	}

	static private enum Operation {
		UNSOLVABLE(true, true, false),
		SOLVABLE(true, false, true),
		QUIET(false, false, false);

		private final boolean status;
		private final boolean unsolvable;
		private final boolean solvable;

		private Operation(boolean status, boolean unsolvable, boolean solvable) {
			this.status = status;
			this.unsolvable = unsolvable;
			this.solvable = solvable;
		}

		private boolean printStatus() {
			return status;
		}

		private boolean printUnsolvable() {
			return unsolvable;
		}

		private boolean printSolvable() {
			return solvable;
		}
	}

	@Override
	public String getShortDescription() {
		return "Print either minimal unsolvable or all solvable words of some class";
	}

	@Override
	public String getLongDescription() {
		return getShortDescription() + ".\n\n"
			+ "This module only prints a subset of all words. For this, an equivalence relation on words "
			+ "is used were two words are equivalent if one can be created from the other by replacing "
			+ "letters with other letters. For example, 'abc' and 'abd' are equivalent in this sense, "
			+ "since c->d turns one into the other.\n"
			+ "More concretely, words are generated so that the last letter of the word is the first "
			+ "letter of the alphabet. Then, the next new letter from the end is the second letter of the "
			+ "alphabet, and so on.\n"
			+ "\nExample calls:\n\n"
			+ " apt " + getName() + " safe solvable abc: Print all words solvable by safe Petri nets over "
			+ "the alphabet {a,b,c}\n"
			+ " apt " + getName() + " none unsolvable ab: Print all minimally unsolvable words over the "
			+ "alphabet {a,b}\n";
	}

	@Override
	public String getName() {
		return "find_words";
	}

	@Override
	public void require(ModuleInputSpec inputSpec) {
		inputSpec.addParameter("options", String.class, "options");
		inputSpec.addParameter("operation", String.class,
				"Choose between printing all 'minimal_unsolvable' words or all 'solvable' words");
		inputSpec.addParameter("alphabet", String.class, "Letters that should be part of the alphabet");
	}

	@Override
	public void provide(ModuleOutputSpec outputSpec) {
		// This module prints to System.out.
	}

	@Override
	public void run(ModuleInput input, ModuleOutput output) throws ModuleException {
		String optionsStr = input.getParameter("options", String.class);
		String alphabetLetter = input.getParameter("alphabet", String.class);
		String operation = input.getParameter("operation", String.class);

		PNProperties properties = SynthesizeModule.Options.parseProperties(optionsStr).properties;
		SortedSet<String> alphabet = new TreeSet<>(toList(alphabetLetter));

		switch (operation) {
			case "minimal_unsolvable":
				generateList(properties, alphabet, Operation.UNSOLVABLE);
				break;
			case "solvable":
				generateList(properties, alphabet, Operation.SOLVABLE);
				break;
			default:
				throw new ModuleException("Unknown operation '" + operation
						+ "', valid options are 'minimal_unsolvable' and 'solvable'");
		}
	}

	static private void generateList(PNProperties properties, SortedSet<String> alphabet, Operation operation) {
		final boolean printSolvable = operation.printSolvable();
		final boolean printUnsolvable = operation.printUnsolvable();
		if (operation.printStatus()) {
			String print;
			if (printSolvable && printUnsolvable)
				print = "solvable and minimal unsolvable";
			else if (printSolvable)
				print = "solvable";
			else if (printUnsolvable)
				print = "minimal unsolvable";
			else
				print = "no";
			System.out.println("Looking for " + print + " words from class " + properties.toString()
					+ " over the alphabet " + alphabet);
		}

		final int[] counters = new int[2];
		// Indices into the above array
		final int solvable = 0;
		final int unsolvable = 1;
		WordCallback wordCallback = new WordCallback() {
			@Override
			public void call(List<String> wordAsList, String wordAsString, SynthesizePN synthesize) {
				if (synthesize.wasSuccessfullySeparated()) {
					counters[solvable]++;
					if (printSolvable)
						System.out.println(wordAsString);
				} else {
					counters[unsolvable]++;
					if (printUnsolvable)
						System.out.println(formatESSPFailure(wordAsList,
									synthesize.getFailedEventStateSeparationProblems(),
									true));
				}
			}
		};
		LengthDoneCallback lengthDoneCallback = new LengthDoneCallback() {
			@Override
			public void call(int length) {
				System.out.println("Done with length " + length + ". There were " + counters[unsolvable]
						+ " unsolvable words and " + counters[solvable] + " solvable words.");
				counters[solvable] = 0;
				counters[unsolvable] = 0;
			}
		};
		generateList(properties, alphabet, !printUnsolvable, wordCallback, lengthDoneCallback);
	}

	static public void generateList(PNProperties properties, SortedSet<String> alphabet, boolean quickFail, WordCallback wordCallback, LengthDoneCallback lengthDoneCallback) {
		List<String> currentLevel = Collections.singletonList("");
		List<String> nextLevel = new ArrayList<>();

		while (!currentLevel.isEmpty()) {
			for (String currentWord : currentLevel) {
				for (String c : alphabet) {
					boolean newLetter = !currentWord.contains(c);

					// If "currentWord" is unsolvable, then "word" must also be unsolvable.
					// Otherwise we get a contradiction: The net solving "word" will solve
					// "currentWord" after firing "c" once.
					// Put differently: By prepending letters to solvable words, we are sure to
					// generate all solvable words.
					String word = c + currentWord;
					word = normalizeWord(toList(word), alphabet);
					List<String> wordList = toList(word);

					if (!properties.isKBounded()) {
						// If we have unbounded places, then every prefix of a solvable word is
						// also solvable: Just add a place from which every transition consumes
						// one token. This place's initial marking limits the length of the
						// word.
						// For our purpose this means: If the prefix isn't solvable, then we
						// already know that the word itself isn't solvable either.
						// This is also important for the definition of "minimally unsolvable"
						// (= unsolvable + all proper subwords are solvable).
						if (Collections.binarySearch(currentLevel, normalizeWord(
								wordList.subList(0, wordList.size() - 1), alphabet)) < 0)
							continue;
					} else {
						// In a k-bounded Petri net, every suffix of a solvable word is also
						// solvable. However, a prefix might still be unsolvable. Thus, we use a
						// different definition of "minimally unsolvable" here (= unsolvable +
						// all proper suffixes are solvable).
					}

					// Is "word" PN-solvable with the given properties?
					TransitionSystem ts = makeTS(wordList);
					SynthesizePN synthesize;
					try {
						synthesize = new SynthesizePN.Builder(ts)
							.setProperties(properties)
							// we don't need failed separation points, if we don't show them
							.setQuickFail(quickFail)
							.buildForLanguageEquivalence();
					} catch (MissingLocationException e) {
						throw new RuntimeException("Not generating locations and "
								+ " yet they were generated wrongly?!", e);
					} catch (NonDeterministicException e) {
						throw new RuntimeException("Generated a deterministic TS and "
								+ " yet it is non-deterministic?!", e);
					}
					wordCallback.call(wordList, word, synthesize);
					if (synthesize.wasSuccessfullySeparated()) {
						nextLevel.add(word);
					}

					if (newLetter)
						// The alphabet is a sorted set. We only extend words in the order that
						// they appear in the alphabet. So if the current letter was new, then
						// all the following ones will be new, too.
						// When extending "ba", "cab" is solvable if and only if "dab" is
						// solvable. So trying other new letters won't produce really "new"
						// words, but only words that are symmetric in the sense that they can
						// be transformed into each other by replacing one letter with another.
						// Avoiding these symmetries in the words we generate helps speeding up
						// this algorithm.
						break;
				}
			}

			int currentLength = currentLevel.iterator().next().length() + 1;
			lengthDoneCallback.call(currentLength);
			currentLevel = nextLevel;
			nextLevel = new ArrayList<>();
			Collections.sort(currentLevel);
		}
	}

	// Transform a String into the list of its characters
	static private List<String> toList(String word) {
		List<String> result = new ArrayList<>(Arrays.asList(word.split("")));
		// some Java versions include "" as first part of the splitted string => try to remove it
		result.remove("");
		return result;
	}

	// Normalize a word into the form that the above loop would generate it in. This means e.g. that the word ends
	// with the first letter of the alphabet.
	static private String normalizeWord(List<String> word, SortedSet<String> alphabet)
	{
		StringBuilder result = new StringBuilder();
		Map<String, String> morphism = new HashMap<>();
		Iterator<String> alphabetIter = alphabet.iterator();

		for (String letter : word) {
			String replacement = morphism.get(letter);
			if (replacement == null) {
				assert alphabetIter.hasNext();
				replacement = alphabetIter.next();
				morphism.put(letter, replacement);
			}
			result.append(replacement);
		}
		return result.toString();
	}

	@Override
	public Category[] getCategories() {
		return new Category[]{Category.LTS};
	}
}

// vim: ft=java:noet:sw=8:sts=8:ts=8:tw=120
